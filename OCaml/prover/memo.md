# Ocaml のモジュールについて
http://qiita.com/szktty/items/6301a2ae9e5bc129a882
http://www.geocities.jp/m_hiroi/func/ocaml09.html

# ファンクター
ファンクターを利用したモジュールは慣習的に XXX.Make と名付けられており、実際標準ライブラリには次のモジュールが含まれています。
Map.Make
Set.Make
Hashtbl.Make
Hashtbl.MakeSeeded
Weak.Make
MoreLabels.Map.Make
MoreLabels.Set.Make
MoreLabels.Hashtbl.Make
MoreLabels.Hashtbl.MakeSeeded


## ファンクターは関数である

* 一言で言えば、ファンクターとは「（引数にモジュールを受け取って、新しいモジュールを返す） 関数 」です。
あれ、知ってた？

* 「（引数にモジュールを受け取って、新しいモジュールを返す） 関数 」
 ですよ？ ファンクターの構文がモジュール定義の変種に見えたとしても、ファンクターは

* 「（新しいモジュールを返す） 関数 」
です。 まず押さえておく点は、ファンクターは
「 関数 」

* 「ファンクターは 関数 です！」

## sig ... end
シグネチャを定義する構文

### シグネチャとは
ストラクチャに対するインターフェースである

.mliでは
``` ocaml
module モジュール名 : (sig ... end)
```
インターフェースというからには、「 sig ... end はインターフェースファイル (.mli) で記述する」ということですね。


.mlでは
``` ocaml
module type モジュール名 : (sig ... end)
```
？？？

sig ... end を「シグネチャ (signature) 」といいます。シグネチャはモジュールの仕様を記述するものですが、OCaml のシグネチャはモジュールの型も表しています。モジュールを定義するとシグネチャが生成されますが、ユーザーがシグネチャを定義して、それをモジュールに設定することもできます。

OCaml の場合、変数の型を指定するときは "変数名 : 型式" で行います。シグネチャはモジュールの型を表すので、"モジュール名 : シグネチャ" でシグネチャを指定することができます。

* データ型は type で記述する。
* 例外は exception で記述する。
* 関数、変数は "val 名前 : 型式" で記述する。


## struct ... end
ストラクチャを定義する構文

### ストラクチャとは
モジュールの実装

「ストラクチャ」と呼ぶと何だか特別そうに聞こえますが、ストラクチャは「モジュールの実装」です。 let 定義、 type 定義、 exception 定義、そういった定義の集合がストラクチャです。まあ type や exception はインターフェースファイルと被るのでわかりにくいかもしれませんけど、 let を含むことからわかるように、ストラクチャはモジュールの実装を表します。だから struct ... end は実装ファイル (.ml) に登場し、ストラクチャをモジュールに束縛する構文 (module モジュール名 = ...) によってモジュールを定義します。

``` ocaml
module モジュール名 = (struct ... end)
```

## 再び：シグネチャとはなんだ
というわけで、ストラクチャは「モジュールの実装」でした。マニュアルによれば、シグネチャは「ストラクチャに対するインターフェース」でした。言い換えると「モジュール実装に対するインターフェース」で、何のことはない、 val と let の関係と同じです。変数や関数を外部に公開する場合、インターフェースファイル (.mli) にはこう記述し、

``` ocaml
val 変数名 : 型
```
実装ファイル (.ml) にはこう記述しますよね。


``` ocaml
let 変数名 = 定義
```

シグネチャとストラクチャも呼び方が異なるだけで、理屈はこれと同じです。ただ、実装ファイルでだけ struct ... end を記述しても、インターフェースファイルにシグネチャを記述しなければ外部から使えません（同じプロジェクトなら使えるけど、インターフェースファイルは書くべきです）。

# モジュール
* シグネチャ + ストラクチャ

* シグネチャ ストラクチャのインターフェース

* ストラクチャ モジュールの実装


* モジュールは struct ... end で実装をすることができるが，
外部からは触ってほしくないものを隠匿するためにインターフェースを利用したい．
それを sig ... end によって実現する．
memo: これくらいの理解でいいか．

# モジュール
データ構造を隠蔽したい場合、シグネチャで宣言する type の右辺を記述しません。具体的には次のようにシグネチャを定義します。

リスト 3 : データ構造の隠蔽

``` ocaml
module type STACK = sig
  type 'a stack
  exception Empty
  val create : 'a stack
  val push : 'a stack -> 'a -> 'a stack
  val pop : 'a stack -> 'a stack
  val top : 'a stack -> 'a
  val is_empty : 'a stack -> bool
end
```

`module Stack1 : STACK = Stack`
シグネチャの名前はモジュールと同様に英大文字から始めます。ここでは STACK としました。モジュールにシグネチャを指定する場合、モジュール名の後ろにコロン ( : ) を付けて、その後ろにシグネチャを指定します。

OCaml の場合、変数の型を指定するときは "変数名 : 型式" で行います。シグネチャはモジュールの型を表すので、"モジュール名 : シグネチャ" でシグネチャを指定することができます。

この他にも、シグネチャは名前を付けずに指定することもできます。簡単な例を示します。

``` ocaml
module Foo : sig ... end = struct ... end
module Foo = (struct ... end : sig ... end)
```

struct の後ろにシグネチャを定義する場合はカッコで囲む必要があります。コロン ( : ) の後ろにシグネチャを指定するところは、どちらの方法でも同じです。

これでコンストラクタを利用することができなくなります。簡単な例を示しましょう。

# let a0 = Stack1.create;;
val a0 : 'a Stack1.stack = <abstr>
<abstr> はデータ構造が隠蔽されていることを表しています。この状態でコンストラクタ SCell や SNil を使うとエラーになります。

このように、データ構造の詳細を隠蔽し、操作関数を使ってデータ構造にアクセスすることを「データ抽象 (data abstraction) 」とか「カプセル化 (encapsulation) 」といいます。わざわざ操作関数を用意するのは面倒なように思われますが、そのことによりプログラムも読みやすくなり、修正にも強いプログラムを作ることができます。

たとえば、スタックの実装をリスト構造から配列に変更することを考えてみましょう。この場合、type の定義はリスト構造から配列に変更されます。もしも、コンストラクタ SCell や SNil を使って直接スタックを操作しているプログラムがあるならば、その箇所を探して修正する必要があります。操作関数だけを使っていて、操作関数の仕様が変わらなければ、スタックを使うプログラムを修正する必要はありません。モジュール Stack を変更するだけで済むわけです。


## コバリアント
## コントラバリアント

t ::=  int | α | t -> t | t*t

P(int, α) = true
P(α, α) = true
P(β, α) (α != β) = true
P(t1->t2, α) = Q(t1,α) ∧ P(t2,α)
P(t1*t2, α) = P(t1, α) ∧ P(t2, α)

Q(int, α) = true
Q(α, α) = false
Q(β, α) (α != β) = true
Q(t1->t2, α) = P(t1, α) ∧ Q(t2, α)
Q(t1*t2, α) = Q(t1, α) ∧ Q(t2, α)

`+` positive
`-` negative

P \ Q
`+`

 P -> Q
`-`

(P -> Q) -> R
`+`

### meta-circular
メタ言語と対象言語が一致している．
自分自身の言語と書いている言語が一致している．


### sharing
let はOcamlのセマンティクスで sharingである


### 多相 p75
let f = fun x -> (x, x)
f は 任意の型に '_a 対して '_a -> '_a * '_a 型 を持つ

これは言い換えができて，

f は 型スキーム 'a -> 'a * 'a を持つ

と言っているのです。ここで「任意の」という部分が消えて，変数の種類が未知の型を表す型変数から好きな型を代入してよい型変数に切り替わったことに注意してください．この変数の種類の切り替えを一般化(generazilation)といいます．


#### シグネチャ
シグネチャで型隠匿してる型のプリティプリントがしたい．どうすればいいのだろうか
http://no-maddojp.hatenablog.com/entry/2015/08/08/155531
