# RSA暗号

# 参考
* https://mathtrain.jp/publickey
* https://mathtrain.jp/rsaango

* http://tsujimotter.hatenablog.com/entry/rsa

* https://qiita.com/jabba/items/e5d6f826d9a8f2cefd60


# 共通鍵暗号のしくみ
# 公開鍵と秘密鍵

## 公開鍵 public key

平文を暗号化するための鍵

例: I love you -> 4338 2838 8779 3020 2011 2838 ...

## 秘密鍵 private key or seclet key

暗号化された文を平文に復号するための鍵

例: 4338 2838 8779 3020 2011 2838 ... -> I love you

## 共通鍵暗号方式
暗号化に必要な鍵と復号化に必要な鍵が同じであるような暗号方式


```
alice(送信者)                                                 bob(受信者)
送りたいメッセージ: m = I love you                            復号のための鍵: k
暗号化のための鍵: k
mとkをもとに暗号文f(m,k)をbobに送る  -> f(m,k) -> f(m,k)とkをもとにf(m,k)を復号化してmを得る
```

* good: 暗号文f(m,k)がバレても共通鍵kがバレなければ暗号文は複合できない
* bad: 最初の共通鍵をどうやって送るのか問題

# 公開鍵暗号のしくみ
## 公開鍵暗号方式
暗号化に必要な鍵と復号化に必要な鍵が異なるような暗号方式

## bobの準備
* 暗号化に用いる鍵(公開鍵): k1 (おれに暗号文を送りたいときは、k1を使ってくれと送信者aliceに渡しておく。)
* 復号化に用いる鍵(秘密鍵): k2 (自分だけ持ってる)
を用意する

```
alice                                                         bob
送りたいメッセージ: m = I love you
暗号化のための鍵(公開鍵): k1                                  復号のための鍵(秘密鍵): k2
mとk1をもとに暗号文f(m,k1)をbobに送る  -> f(m,k1) -> f(m,k1)とk2をもとにf(m,k1)を復号化してmを得る
```

* good: 暗号文f(m, k1)と公開鍵k1がバレても、暗号文は複合できない。秘密鍵は、共有せず受信者しか知らないので秘密鍵がバレる心配がまずない。

送信者と受信者を固定して考えていたが、双方向にやりとりをしたいときは，二人が別々に公開鍵，秘密鍵を作ればおｋ

## 注意すること
### 公開鍵暗号に必要な条件
* f(m,k1)とk1からmは複合できない(防御のため)
* f(m,k1)とk2からmが複合できる(復号のため)

このような条件を満たす方式としてRSA暗号方式がある。

---
---

# RSA暗号
## 数学的準備 (初等整数論の基礎知識)
* 合同式 https://mathtrain.jp/mod
* フェルマーの小定理 https://mathtrain.jp/fermat_petit
* オイラーの定理: $$a$$, $$b$$ が互いに素なとき、$$a x \equiv 1 \bmod b$$ なる $$x$$ が$$1 \leq x \leg b -1 $$ の間でただ一つだけ存在する。

### 合同式

* $$32 \bmod 10 = 2$$ とは、32を10で割ったあまりが2ということ

* $$32 \equiv 2 \pmod{10}$$ とは、mod 10の世界で、32と2は等しいということ

### フェルマーの小定理

* $$p$$ が素数，$$a$$が任意の自然数のとき
$$a^p \equiv a \pmod{p}$$

* 特に，$$p$$ と $$a$$ が互いに素な自然数のとき
$$a^{p−1} \equiv 1 \pmod{p}$$

この小定理の意味するところは、$$\bmod p$$ の世界で、aをp-1回べき乗すると1に戻るということ

### オイラーの定理
* aとbが互いに素なとき
$$a x \equiv 1 \pmod{b}$$ なるxが $$1 \leq x \leq b-1$$ の間でただ一つ存在する。

## RSA暗号の仕組み
メッセージを受け取る側の準備
* 大きな整数p,q を生成し、 $$n = pq$$とする。(nは公開鍵)
* (p-1)(q-1)と互いに素な整数k1を取ってくる。(k1は公開鍵)
* $$k1 k2 \equiv 1 \pmod{(p-1)(q-1)}$$ となる整数k2を取ってくる。(k2は秘密鍵)
オイラーの定理より、 $$0 \leq k2 \leq (p-1)(q-1)$$とすると、k2は一意に定まる。
ココまでの操作は、高速にできることが知られている。
* n と k1 を公開する(公開鍵)、
* k2は公開しない(秘密鍵)

メッセージを送る側の暗号化方法
* 送りたいメッセージを平文mとする(ただし、$$0 \leq m \leq n$$)
* 公開鍵k1を用いて$$m^{k1} \bmod n$$を計算し、これを暗号文$$C$$とする。

メッセージを受け取る側の復号化方法
* 暗号文Cと秘密鍵k2を用いて$$C^{k1} \bmod n$$を計算する
* その計算結果が平文mと一致する。

安全性
* 暗号文Cと公開鍵n,k1がわかっても、平文mは(現実的な時間では)復元できないと信じられている。

## 復号がうまくいく理由

暗号化：$$m^{k1} \bmod n$$
復号化：$$C^{k2} \bmod n$$
